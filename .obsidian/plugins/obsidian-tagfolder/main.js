/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// main.ts
__export(exports, {
  default: () => TagFolderPlugin
});
var import_obsidian4 = __toModule(require("obsidian"));

// node_modules/svelte/internal/index.mjs
function noop() {
}
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return tar;
}
function run(fn) {
  return fn();
}
function blank_object() {
  return Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
var tasks = new Set();
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.wholeText !== data)
    text2.data = data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  node.style.setProperty(key, value, important ? "important" : "");
}
function toggle_class(element2, name, toggle) {
  element2.classList[toggle ? "add" : "remove"](name);
}
var active_docs = new Set();
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var flushing = false;
var seen_callbacks = new Set();
function flush() {
  if (flushing)
    return;
  flushing = true;
  do {
    for (let i = 0; i < dirty_components.length; i += 1) {
      const component = dirty_components[i];
      set_current_component(component);
      update(component.$$);
    }
    set_current_component(null);
    dirty_components.length = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  flushing = false;
  seen_callbacks.clear();
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
var outroing = new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  }
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
var boolean_attributes = new Set([
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
]);
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, on_mount, on_destroy, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = on_mount.map(run).filter(is_function);
      if (on_destroy) {
        on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance5, create_fragment5, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: null,
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance5 ? instance5(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment5 ? create_fragment5($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/store/index.mjs
var subscriber_queue = [];
function writable(value, start = noop) {
  let stop;
  const subscribers = new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}

// store.ts
var treeRoot = writable();
var currentFile = writable("");
var maxDepth = writable(0);
var filterString = writable("");
var tagInfo = writable({});

// types.ts
var SUBTREE_MARK = "\u2192 ";
var SUBTREE_MARK_REGEX = /\/→ /g;
var DEFAULT_SETTINGS = {
  displayMethod: "NAME",
  alwaysOpen: false,
  ignoreDocTags: "",
  ignoreTags: "",
  hideOnRootTags: "",
  sortType: "DISPNAME_ASC",
  sortTypeTag: "NAME_ASC",
  expandLimit: 0,
  disableNestedTags: false,
  hideItems: "NONE",
  ignoreFolders: "",
  targetFolders: "",
  scanDelay: 250,
  useTitle: true,
  reduceNestedParent: true,
  frontmatterKey: "title",
  useTagInfo: false,
  tagInfo: "pininfo.md",
  mergeRedundantCombination: false,
  useVirtualTag: false
};
var VIEW_TYPE_SCROLL = "tagfolder-view-scroll";
var EPOCH_MINUTE = 60;
var EPOCH_HOUR = EPOCH_MINUTE * 60;
var EPOCH_DAY = EPOCH_HOUR * 24;
var FRESHNESS_1 = "FRESHNESS_01";
var FRESHNESS_2 = "FRESHNESS_02";
var FRESHNESS_3 = "FRESHNESS_03";
var FRESHNESS_4 = "FRESHNESS_04";
var FRESHNESS_5 = "FRESHNESS_05";
var tagDispDict = {
  FRESHNESS_01: "\u{1F550}",
  FRESHNESS_02: "\u{1F4D6}",
  FRESHNESS_03: "\u{1F4D7}",
  FRESHNESS_04: "\u{1F4DA}",
  FRESHNESS_05: "\u{1F5C4}",
  _VIRTUAL_TAG_FRESHNESS: "\u231B"
};

// util.ts
function unique(items) {
  return [...new Set([...items])];
}
function allTags(entry) {
  var _a;
  if ("tags" in entry)
    return entry.tags;
  return unique([...((_a = entry == null ? void 0 : entry.descendants) != null ? _a : []).flatMap((e) => e.tags), ...entry.children.flatMap((e) => "tag" in e ? allTags(e) : e.tags).filter((e) => e)]);
}
function isAutoExpandTree(entry) {
  var _a;
  if ("tag" in entry) {
    const childrenTags = entry.children.filter((e) => "tag" in e);
    const childrenItems = ((_a = entry.allDescendants) != null ? _a : entry.children).filter((e) => "tags" in e);
    if (childrenTags.length == 0)
      return false;
    if (entry.itemsCount == 1)
      return true;
    if (childrenTags.length == 1 && childrenItems.length == 0) {
      return true;
    }
    if (childrenTags.length == 1 && childrenItems.length > 1) {
      const sTags = allTags(entry).join("-").toLocaleLowerCase();
      for (const child of childrenItems) {
        const cTags = allTags(child).join("-").toLocaleLowerCase();
        if (sTags != cTags) {
          return false;
        }
      }
      return true;
    }
  }
  return false;
}
function omittedTags(entry) {
  var _a;
  const childrenTags = entry.children.filter((e) => "tag" in e);
  const childrenItems = ((_a = entry.allDescendants) != null ? _a : entry.children).filter((e) => "tags" in e);
  if (childrenTags.length > 0)
    return false;
  const tx = childrenItems.map((e) => [...e.tags].sort().join("-"));
  if (tx.length != 1 && entry.itemsCount != 1)
    return false;
  const tags = unique(childrenItems.flatMap((e) => e.tags));
  const ancestorTags = ancestorToTags(entry.ancestors).map((e) => e.toLocaleLowerCase());
  const lastT = tags.filter((e) => !ancestorTags.contains(e.toLocaleLowerCase()));
  if (lastT.length) {
    return lastT;
  }
  return false;
}
function ancestorToTags(ancestors) {
  const SUBTREE_MARK_LENGTH = SUBTREE_MARK.length;
  return ancestors.reduce((p, i) => !i.startsWith(SUBTREE_MARK) ? [...p, i] : [
    ...p,
    p.pop() + "/" + i.substring(SUBTREE_MARK_LENGTH)
  ], []);
}
function ancestorToLongestTag(ancestors) {
  return ancestors.reduceRight((a, e) => !a ? [e] : a[0].startsWith(e) ? a : [e, ...a], null);
}
function isSpecialTag(tagSrc) {
  const tag = tagSrc.startsWith(SUBTREE_MARK) ? tagSrc.substring(SUBTREE_MARK.length) : tagSrc;
  return tag == "_untagged" || tag in tagDispDict;
}
function renderSpecialTag(tagSrc) {
  const tag = tagSrc.startsWith(SUBTREE_MARK) ? tagSrc.substring(SUBTREE_MARK.length) : tagSrc;
  return tag in tagDispDict ? tagDispDict[tag] : tag;
}
function secondsToFreshness(totalAsMSec) {
  const totalAsSec = ~~(totalAsMSec / 1e3);
  const sign = totalAsSec / Math.abs(totalAsSec);
  const totalSec = ~~(totalAsSec * sign);
  if (totalSec < EPOCH_HOUR)
    return FRESHNESS_1;
  if (totalSec < EPOCH_HOUR * 6)
    return FRESHNESS_2;
  if (totalSec < EPOCH_DAY * 3)
    return FRESHNESS_3;
  if (totalSec < EPOCH_DAY * 7)
    return FRESHNESS_4;
  return FRESHNESS_5;
}
var lastSkipped = 0;
var doEvents = () => {
  const n = performance.now();
  if (n - lastSkipped < 20) {
    return Promise.resolve();
  }
  return new Promise((res) => {
    window.requestAnimationFrame(() => {
      lastSkipped = performance.now();
      res();
    });
  });
};

// TreeItemComponent.svelte
function add_css(target) {
  append_styles(target, "svelte-brpr9m", ".lsl-f.svelte-brpr9m.svelte-brpr9m{flex-direction:row;display:flex;flex-grow:1;max-width:100%}.tagfolder-titletagname.svelte-brpr9m.svelte-brpr9m{flex-grow:1;max-width:calc(100% - 2em);width:calc(100% - 2em);text-overflow:ellipsis;overflow:hidden;white-space:nowrap;overflow:hidden}.nav-folder-title-content.svelte-brpr9m:hover .tagfolder-quantity span.svelte-brpr9m{background-color:var(--interactive-accent-hover);color:var(--text-on-accent)}.tagfolder-quantity.svelte-brpr9m span.svelte-brpr9m{background-color:var(--background-secondary-alt);border-radius:4px;padding:2px 4px}.tagfolder-quantity.svelte-brpr9m.svelte-brpr9m{width:3em;text-align:right;cursor:pointer}.tag-folder-title.svelte-brpr9m.svelte-brpr9m{max-width:100%}");
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[35] = list[i];
  return child_ctx;
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[35] = list[i];
  return child_ctx;
}
function create_if_block_4(ctx) {
  let div2;
  let div1;
  let div0;
  let t_value = ctx[0].displayName + "";
  let t;
  let mounted;
  let dispose;
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      t = text(t_value);
      attr(div0, "class", "nav-file-title-content");
      attr(div1, "class", "nav-file-title");
      toggle_class(div1, "is-active", ctx[10]);
      attr(div2, "class", "nav-file");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      append(div0, t);
      if (!mounted) {
        dispose = [
          listen(div1, "click", ctx[32]),
          listen(div1, "mouseover", ctx[33]),
          listen(div1, "focus", focus_handler),
          listen(div1, "contextmenu", function() {
            if (is_function(ctx[18](ctx[0])))
              ctx[18](ctx[0]).apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 1 && t_value !== (t_value = ctx[0].displayName + ""))
        set_data(t, t_value);
      if (dirty[0] & 1024) {
        toggle_class(div1, "is-active", ctx[10]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div2);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2(ctx) {
  let div5;
  let div4;
  let div0;
  let t0;
  let div3;
  let div1;
  let t1;
  let t2;
  let t3;
  let div2;
  let span;
  let t4_value = ctx[0].itemsCount + "";
  let t4;
  let t5;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[13].length > 0 && create_if_block_3(ctx);
  return {
    c() {
      div5 = element("div");
      div4 = element("div");
      div0 = element("div");
      t0 = space();
      div3 = element("div");
      div1 = element("div");
      t1 = text(ctx[11]);
      t2 = text(ctx[12]);
      t3 = space();
      div2 = element("div");
      span = element("span");
      t4 = text(t4_value);
      t5 = space();
      if (if_block)
        if_block.c();
      attr(div0, "class", "nav-folder-collapse-indicator collapse-icon");
      attr(div1, "class", "tagfolder-titletagname svelte-brpr9m");
      attr(span, "class", "itemscount svelte-brpr9m");
      attr(div2, "class", "tagfolder-quantity itemscount svelte-brpr9m");
      attr(div3, "class", "nav-folder-title-content lsl-f svelte-brpr9m");
      attr(div4, "class", "nav-folder-title tag-folder-title svelte-brpr9m");
      toggle_class(div4, "is-active", ctx[0].children && ctx[7] && ctx[10]);
      attr(div5, "class", "nav-folder");
      toggle_class(div5, "is-collapsed", ctx[7]);
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div4);
      append(div4, div0);
      div0.innerHTML = ctx[6];
      append(div4, t0);
      append(div4, div3);
      append(div3, div1);
      append(div1, t1);
      append(div1, t2);
      append(div3, t3);
      append(div3, div2);
      append(div2, span);
      append(span, t4);
      append(div5, t5);
      if (if_block)
        if_block.m(div5, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div2, "click", ctx[30]),
          listen(div4, "click", ctx[31]),
          listen(div4, "contextmenu", function() {
            if (is_function(ctx[18](ctx[0])))
              ctx[18](ctx[0]).apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty[0] & 64)
        div0.innerHTML = ctx[6];
      ;
      if (!current || dirty[0] & 2048)
        set_data(t1, ctx[11]);
      if (!current || dirty[0] & 4096)
        set_data(t2, ctx[12]);
      if ((!current || dirty[0] & 1) && t4_value !== (t4_value = ctx[0].itemsCount + ""))
        set_data(t4, t4_value);
      if (dirty[0] & 1153) {
        toggle_class(div4, "is-active", ctx[0].children && ctx[7] && ctx[10]);
      }
      if (ctx[13].length > 0) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[0] & 8192) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_3(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div5, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty[0] & 128) {
        toggle_class(div5, "is-collapsed", ctx[7]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[13].length > 0 && create_if_block_1(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[13].length > 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 8192) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_3(ctx) {
  let div;
  let current;
  let each_value_1 = ctx[13];
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "nav-folder-children");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 24702) {
        each_value_1 = ctx2[13];
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_1(ctx) {
  let treeitemcomponent;
  let current;
  treeitemcomponent = new TreeItemComponent({
    props: {
      entry: ctx[35],
      openfile: ctx[2],
      hoverPreview: ctx[1],
      expandFolder: ctx[3],
      showMenu: ctx[4],
      openScrollView: ctx[5],
      path: ctx[14],
      folderIcon: ctx[6]
    }
  });
  return {
    c() {
      create_component(treeitemcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(treeitemcomponent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const treeitemcomponent_changes = {};
      if (dirty[0] & 8192)
        treeitemcomponent_changes.entry = ctx2[35];
      if (dirty[0] & 4)
        treeitemcomponent_changes.openfile = ctx2[2];
      if (dirty[0] & 2)
        treeitemcomponent_changes.hoverPreview = ctx2[1];
      if (dirty[0] & 8)
        treeitemcomponent_changes.expandFolder = ctx2[3];
      if (dirty[0] & 16)
        treeitemcomponent_changes.showMenu = ctx2[4];
      if (dirty[0] & 32)
        treeitemcomponent_changes.openScrollView = ctx2[5];
      if (dirty[0] & 16384)
        treeitemcomponent_changes.path = ctx2[14];
      if (dirty[0] & 64)
        treeitemcomponent_changes.folderIcon = ctx2[6];
      treeitemcomponent.$set(treeitemcomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(treeitemcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(treeitemcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(treeitemcomponent, detaching);
    }
  };
}
function create_if_block_1(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[13];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 26750) {
        each_value = ctx2[13];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block(ctx) {
  let treeitemcomponent;
  let current;
  treeitemcomponent = new TreeItemComponent({
    props: {
      entry: ctx[35],
      openfile: ctx[2],
      hoverPreview: ctx[1],
      expandFolder: ctx[3],
      showMenu: ctx[4],
      openScrollView: ctx[5],
      skippedTag: ctx[11],
      path: ctx[14],
      folderIcon: ctx[6]
    }
  });
  return {
    c() {
      create_component(treeitemcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(treeitemcomponent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const treeitemcomponent_changes = {};
      if (dirty[0] & 8192)
        treeitemcomponent_changes.entry = ctx2[35];
      if (dirty[0] & 4)
        treeitemcomponent_changes.openfile = ctx2[2];
      if (dirty[0] & 2)
        treeitemcomponent_changes.hoverPreview = ctx2[1];
      if (dirty[0] & 8)
        treeitemcomponent_changes.expandFolder = ctx2[3];
      if (dirty[0] & 16)
        treeitemcomponent_changes.showMenu = ctx2[4];
      if (dirty[0] & 32)
        treeitemcomponent_changes.openScrollView = ctx2[5];
      if (dirty[0] & 2048)
        treeitemcomponent_changes.skippedTag = ctx2[11];
      if (dirty[0] & 16384)
        treeitemcomponent_changes.path = ctx2[14];
      if (dirty[0] & 64)
        treeitemcomponent_changes.folderIcon = ctx2[6];
      treeitemcomponent.$set(treeitemcomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(treeitemcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(treeitemcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(treeitemcomponent, detaching);
    }
  };
}
function fallback_block(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_if_block_2, create_if_block_4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[9])
      return 0;
    if (show_if == null || dirty[0] & 257)
      show_if = !!("tag" in ctx2[0] && (ctx2[15] <= ctx2[8] || ctx2[0].tag.startsWith(SUBTREE_MARK)));
    if (show_if)
      return 1;
    if ("path" in ctx2[0])
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, [-1, -1]))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment(ctx) {
  let current;
  const default_slot_template = ctx[29].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[28], null);
  const default_slot_or_fallback = default_slot || fallback_block(ctx);
  return {
    c() {
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & 268435456)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[28], !current ? get_all_dirty_from_scope(ctx2[28]) : get_slot_changes(default_slot_template, ctx2[28], dirty, null), null);
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty[0] & 32767)) {
          default_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
}
function getItemPath(item, basepath) {
  if (item && "tag" in item) {
    return basepath + item.tag + "/";
  }
  return basepath;
}
function getFilenames(entry) {
  if (entry.allDescendants == null) {
    return [];
  } else {
    const filenames = entry.allDescendants.map((e) => e.path);
    return Array.from(new Set([...filenames]));
  }
}
var focus_handler = () => {
};
function instance($$self, $$props, $$invalidate) {
  let currentPath;
  let curTaginfo;
  let tagMark;
  let convertedTag;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { entry } = $$props;
  let { hoverPreview } = $$props;
  let { openfile } = $$props;
  let { expandFolder } = $$props;
  let { showMenu } = $$props;
  let { path } = $$props;
  let { skippedTag } = $$props;
  let { openScrollView } = $$props;
  let { folderIcon } = $$props;
  let collapsed = true;
  let isSelected = false;
  const currentDepth = path.replace(SUBTREE_MARK_REGEX, "###").split("/").length;
  let _maxDepth = currentDepth + 1;
  function toggleFolder(evt, entry2) {
    if (evt.target instanceof HTMLElement && evt.target.hasClass("itemscount"))
      return;
    if ("tag" in entry2) {
      expandFolder(entry2, collapsed);
      $$invalidate(7, collapsed = !collapsed);
    }
  }
  function openfileLocal(entry2, evt) {
    if ("path" in entry2)
      openfile(entry2.path, evt.metaKey || evt.ctrlKey);
  }
  function handleContextMenu(e, path2, entry2) {
    showMenu(e, path2, entry2);
  }
  function contextMenuFunc(entry2) {
    const _path = currentPath;
    const _entry = entry2;
    return (e) => {
      handleContextMenu(e, _path, _entry);
    };
  }
  function handleMouseover(e, entry2) {
    if (entry2 && "path" in entry2)
      hoverPreview(e, entry2.path);
  }
  function handleOpenScroll(e, entry2) {
    if ("tag" in entry2) {
      openScrollView(null, "", entry2.ancestors.join("/"), entry2.allDescendants.map((e2) => e2.path));
      e.preventDefault();
    }
  }
  currentFile.subscribe((path2) => {
    $$invalidate(10, isSelected = false);
    if ("tags" in entry && entry.path == path2) {
      $$invalidate(10, isSelected = true);
    }
    if ("tag" in entry && getFilenames(entry).indexOf(path2) !== -1) {
      $$invalidate(10, isSelected = true);
    }
  });
  let _tagInfo = {};
  maxDepth.subscribe((depth) => {
    $$invalidate(8, _maxDepth = depth);
    if (depth == 0) {
      $$invalidate(8, _maxDepth = currentDepth + 1);
    }
  });
  tagInfo.subscribe((info) => {
    $$invalidate(23, _tagInfo = info);
  });
  let tagTitle = "";
  let showOnlyChildren = false;
  let ellipsisMark = "";
  let omitTags = [];
  let children2 = [];
  const click_handler = (e) => handleOpenScroll(e, entry);
  const click_handler_1 = (evt) => toggleFolder(evt, entry);
  const click_handler_2 = (evt) => openfileLocal(entry, evt);
  const mouseover_handler = (e) => handleMouseover(e, entry);
  $$self.$$set = ($$props2) => {
    if ("entry" in $$props2)
      $$invalidate(0, entry = $$props2.entry);
    if ("hoverPreview" in $$props2)
      $$invalidate(1, hoverPreview = $$props2.hoverPreview);
    if ("openfile" in $$props2)
      $$invalidate(2, openfile = $$props2.openfile);
    if ("expandFolder" in $$props2)
      $$invalidate(3, expandFolder = $$props2.expandFolder);
    if ("showMenu" in $$props2)
      $$invalidate(4, showMenu = $$props2.showMenu);
    if ("path" in $$props2)
      $$invalidate(21, path = $$props2.path);
    if ("skippedTag" in $$props2)
      $$invalidate(22, skippedTag = $$props2.skippedTag);
    if ("openScrollView" in $$props2)
      $$invalidate(5, openScrollView = $$props2.openScrollView);
    if ("folderIcon" in $$props2)
      $$invalidate(6, folderIcon = $$props2.folderIcon);
    if ("$$scope" in $$props2)
      $$invalidate(28, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 16777217) {
      $: {
        $$invalidate(9, showOnlyChildren = false);
        $$invalidate(12, ellipsisMark = "");
        $$invalidate(24, omitTags = []);
        if ("tag" in entry) {
          $$invalidate(9, showOnlyChildren = isAutoExpandTree(entry));
          const omitTag = omittedTags(entry);
          if (omitTag !== false) {
            $$invalidate(24, omitTags = [
              ...omitTag.map((e) => e.split("/").map((ee) => renderSpecialTag(ee)).join("/"))
            ]);
            $$invalidate(12, ellipsisMark = "/" + omitTags.join("/"));
          }
        }
      }
    }
    if ($$self.$$.dirty[0] & 18874369) {
      $:
        $$invalidate(14, currentPath = getItemPath(entry, path) + omitTags.map((e) => "/" + e).join(""));
    }
    if ($$self.$$.dirty[0] & 8388609) {
      $:
        $$invalidate(27, curTaginfo = "tag" in entry && entry.tag in _tagInfo ? _tagInfo[entry.tag] : null);
    }
    if ($$self.$$.dirty[0] & 134217728) {
      $:
        $$invalidate(26, tagMark = !curTaginfo ? "" : "mark" in curTaginfo && curTaginfo.mark ? curTaginfo.mark : "\u{1F4CC}");
    }
    if ($$self.$$.dirty[0] & 1) {
      $:
        $$invalidate(25, convertedTag = "tag" in entry ? renderSpecialTag(entry.tag) : "");
    }
    if ($$self.$$.dirty[0] & 104857601) {
      $:
        $$invalidate(11, tagTitle = "tag" in entry ? `${skippedTag ? `${skippedTag}${entry.tag.startsWith(SUBTREE_MARK) ? " " : "/"}` : ""}${tagMark}${convertedTag}` : "");
    }
    if ($$self.$$.dirty[0] & 897) {
      $: {
        let cx = [];
        if ("tag" in entry) {
          if (showOnlyChildren) {
            cx = [...cx, ...entry.children.filter((e) => "tag" in e)];
          } else {
            if (entry.children && !collapsed) {
              cx = [...cx, ...entry.children.filter((e) => "tag" in e)];
            }
            if (_maxDepth != 1 && currentDepth > _maxDepth && entry.allDescendants && !collapsed) {
              cx = [...cx, ...entry.allDescendants];
            }
            if (entry.descendants && !collapsed) {
              cx = [...cx, ...entry.descendants];
            }
          }
          $$invalidate(13, children2 = cx);
        }
      }
    }
  };
  return [
    entry,
    hoverPreview,
    openfile,
    expandFolder,
    showMenu,
    openScrollView,
    folderIcon,
    collapsed,
    _maxDepth,
    showOnlyChildren,
    isSelected,
    tagTitle,
    ellipsisMark,
    children2,
    currentPath,
    currentDepth,
    toggleFolder,
    openfileLocal,
    contextMenuFunc,
    handleMouseover,
    handleOpenScroll,
    path,
    skippedTag,
    _tagInfo,
    omitTags,
    convertedTag,
    tagMark,
    curTaginfo,
    $$scope,
    slots,
    click_handler,
    click_handler_1,
    click_handler_2,
    mouseover_handler
  ];
}
var TreeItemComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {
      entry: 0,
      hoverPreview: 1,
      openfile: 2,
      expandFolder: 3,
      showMenu: 4,
      path: 21,
      skippedTag: 22,
      openScrollView: 5,
      folderIcon: 6
    }, add_css, [-1, -1]);
  }
};
var TreeItemComponent_default = TreeItemComponent;

// TagFolderViewComponent.svelte
var import_obsidian = __toModule(require("obsidian"));
function add_css2(target) {
  append_styles(target, "svelte-1lyxrts", ".nav-folder.svelte-1lyxrts{padding-bottom:64px}.nav-files-container.svelte-1lyxrts{height:100%}");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i];
  return child_ctx;
}
function create_if_block2(ctx) {
  let div1;
  let input;
  let t;
  let div0;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      input = element("input");
      t = space();
      div0 = element("div");
      attr(input, "type", "text");
      attr(input, "spellcheck", "false");
      attr(input, "placeholder", "Type to start search...");
      attr(div0, "class", "search-input-clear-button");
      attr(div0, "aria-label", "Clear search");
      set_style(div0, "display", "none");
      attr(div1, "class", "search-input-container");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, input);
      set_input_value(input, ctx[10]);
      append(div1, t);
      append(div1, div0);
      if (!mounted) {
        dispose = listen(input, "input", ctx[21]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1024 && input.value !== ctx2[10]) {
        set_input_value(input, ctx2[10]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block2(ctx) {
  let treeitemcomponent;
  let current;
  treeitemcomponent = new TreeItemComponent_default({
    props: {
      entry: ctx[22],
      hoverPreview: ctx[1],
      openfile: ctx[2],
      expandFolder: ctx[3],
      showMenu: ctx[5],
      skippedTag: "",
      path: "/",
      openScrollView: ctx[9],
      folderIcon: ctx[14]
    }
  });
  return {
    c() {
      create_component(treeitemcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(treeitemcomponent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const treeitemcomponent_changes = {};
      if (dirty & 1)
        treeitemcomponent_changes.entry = ctx2[22];
      if (dirty & 2)
        treeitemcomponent_changes.hoverPreview = ctx2[1];
      if (dirty & 4)
        treeitemcomponent_changes.openfile = ctx2[2];
      if (dirty & 8)
        treeitemcomponent_changes.expandFolder = ctx2[3];
      if (dirty & 32)
        treeitemcomponent_changes.showMenu = ctx2[5];
      if (dirty & 512)
        treeitemcomponent_changes.openScrollView = ctx2[9];
      if (dirty & 16384)
        treeitemcomponent_changes.folderIcon = ctx2[14];
      treeitemcomponent.$set(treeitemcomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(treeitemcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(treeitemcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(treeitemcomponent, detaching);
    }
  };
}
function create_fragment2(ctx) {
  let div0;
  let t0;
  let div6;
  let div5;
  let div1;
  let t1;
  let div2;
  let t2;
  let div3;
  let t3;
  let div4;
  let t4;
  let div12;
  let t5;
  let div11;
  let div9;
  let div7;
  let t6;
  let div8;
  let t7;
  let t8;
  let t9;
  let div10;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[11] && create_if_block2(ctx);
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div0 = element("div");
      t0 = space();
      div6 = element("div");
      div5 = element("div");
      div1 = element("div");
      t1 = space();
      div2 = element("div");
      t2 = space();
      div3 = element("div");
      t3 = space();
      div4 = element("div");
      t4 = space();
      div12 = element("div");
      if (if_block)
        if_block.c();
      t5 = space();
      div11 = element("div");
      div9 = element("div");
      div7 = element("div");
      t6 = space();
      div8 = element("div");
      t7 = text("Tags: ");
      t8 = text(ctx[4]);
      t9 = space();
      div10 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      div0.hidden = true;
      attr(div1, "class", "clickable-icon nav-action-button");
      attr(div1, "aria-label", "New note");
      attr(div2, "class", "clickable-icon nav-action-button");
      attr(div2, "aria-label", "Change sort order");
      attr(div3, "class", "clickable-icon nav-action-button");
      attr(div3, "aria-label", "Expand limit");
      attr(div4, "class", "clickable-icon nav-action-button");
      attr(div4, "aria-label", "Search");
      attr(div5, "class", "nav-buttons-container tagfolder-buttons-container");
      attr(div6, "class", "nav-header");
      attr(div7, "class", "nav-folder-collapse-indicator collapse-icon");
      attr(div8, "class", "nav-folder-title-content");
      attr(div9, "class", "nav-folder-title");
      attr(div10, "class", "nav-folder-children");
      attr(div11, "class", "nav-folder mod-root svelte-1lyxrts");
      attr(div12, "class", "nav-files-container svelte-1lyxrts");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      ctx[20](div0);
      insert(target, t0, anchor);
      insert(target, div6, anchor);
      append(div6, div5);
      append(div5, div1);
      div1.innerHTML = ctx[13];
      append(div5, t1);
      append(div5, div2);
      div2.innerHTML = ctx[15];
      append(div5, t2);
      append(div5, div3);
      div3.innerHTML = ctx[16];
      append(div5, t3);
      append(div5, div4);
      div4.innerHTML = ctx[17];
      insert(target, t4, anchor);
      insert(target, div12, anchor);
      if (if_block)
        if_block.m(div12, null);
      append(div12, t5);
      append(div12, div11);
      append(div11, div9);
      append(div9, div7);
      append(div9, t6);
      append(div9, div8);
      append(div8, t7);
      append(div8, t8);
      append(div11, t9);
      append(div11, div10);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div10, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(div1, "click", function() {
            if (is_function(ctx[8]))
              ctx[8].apply(this, arguments);
          }),
          listen(div2, "click", function() {
            if (is_function(ctx[7]))
              ctx[7].apply(this, arguments);
          }),
          listen(div3, "click", function() {
            if (is_function(ctx[6]))
              ctx[6].apply(this, arguments);
          }),
          listen(div4, "click", ctx[18])
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (!current || dirty & 8192)
        div1.innerHTML = ctx[13];
      ;
      if (!current || dirty & 32768)
        div2.innerHTML = ctx[15];
      ;
      if (!current || dirty & 65536)
        div3.innerHTML = ctx[16];
      ;
      if (!current || dirty & 131072)
        div4.innerHTML = ctx[17];
      ;
      if (ctx[11]) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block2(ctx);
          if_block.c();
          if_block.m(div12, t5);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty & 16)
        set_data(t8, ctx[4]);
      if (dirty & 16943) {
        each_value = ctx[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div10, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      ctx[20](null);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div6);
      if (detaching)
        detach(t4);
      if (detaching)
        detach(div12);
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { items = [] } = $$props;
  let { hoverPreview } = $$props;
  let { openfile } = $$props;
  let { expandFolder } = $$props;
  let { vaultname = "" } = $$props;
  let { showMenu } = $$props;
  let { showLevelSelect } = $$props;
  let { showOrder } = $$props;
  let { newNote } = $$props;
  let { setSearchString } = $$props;
  let { openScrollView } = $$props;
  treeRoot.subscribe((root) => {
    var _a;
    $$invalidate(0, items = (_a = root === null || root === void 0 ? void 0 : root.children) !== null && _a !== void 0 ? _a : []);
  });
  let search = "";
  let showSearch = false;
  function toggleSearch() {
    $$invalidate(11, showSearch = !showSearch);
    if (!showSearch) {
      $$invalidate(10, search = "");
    }
  }
  let iconDivEl;
  let documentIcon = "";
  let folderIcon = "";
  let upAndDownArrowsIcon = "";
  let stackedLevels = "";
  let searchIcon = "";
  onMount(async () => {
    (0, import_obsidian.setIcon)(iconDivEl, "right-triangle", 24);
    $$invalidate(14, folderIcon = `${iconDivEl.innerHTML}`);
    (0, import_obsidian.setIcon)(iconDivEl, "document", 20);
    $$invalidate(13, documentIcon = `${iconDivEl.innerHTML}`);
    (0, import_obsidian.setIcon)(iconDivEl, "lucide-sort-asc", 20);
    $$invalidate(15, upAndDownArrowsIcon = iconDivEl.innerHTML);
    (0, import_obsidian.setIcon)(iconDivEl, "stacked-levels", 20);
    $$invalidate(16, stackedLevels = iconDivEl.innerHTML);
    (0, import_obsidian.setIcon)(iconDivEl, "search", 20);
    $$invalidate(17, searchIcon = iconDivEl.innerHTML);
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      iconDivEl = $$value;
      $$invalidate(12, iconDivEl);
    });
  }
  function input_input_handler() {
    search = this.value;
    $$invalidate(10, search);
  }
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(0, items = $$props2.items);
    if ("hoverPreview" in $$props2)
      $$invalidate(1, hoverPreview = $$props2.hoverPreview);
    if ("openfile" in $$props2)
      $$invalidate(2, openfile = $$props2.openfile);
    if ("expandFolder" in $$props2)
      $$invalidate(3, expandFolder = $$props2.expandFolder);
    if ("vaultname" in $$props2)
      $$invalidate(4, vaultname = $$props2.vaultname);
    if ("showMenu" in $$props2)
      $$invalidate(5, showMenu = $$props2.showMenu);
    if ("showLevelSelect" in $$props2)
      $$invalidate(6, showLevelSelect = $$props2.showLevelSelect);
    if ("showOrder" in $$props2)
      $$invalidate(7, showOrder = $$props2.showOrder);
    if ("newNote" in $$props2)
      $$invalidate(8, newNote = $$props2.newNote);
    if ("setSearchString" in $$props2)
      $$invalidate(19, setSearchString = $$props2.setSearchString);
    if ("openScrollView" in $$props2)
      $$invalidate(9, openScrollView = $$props2.openScrollView);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 525312) {
      $: {
        if (setSearchString != null) {
          setSearchString(search);
        }
      }
    }
  };
  return [
    items,
    hoverPreview,
    openfile,
    expandFolder,
    vaultname,
    showMenu,
    showLevelSelect,
    showOrder,
    newNote,
    openScrollView,
    search,
    showSearch,
    iconDivEl,
    documentIcon,
    folderIcon,
    upAndDownArrowsIcon,
    stackedLevels,
    searchIcon,
    toggleSearch,
    setSearchString,
    div0_binding,
    input_input_handler
  ];
}
var TagFolderViewComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      items: 0,
      hoverPreview: 1,
      openfile: 2,
      expandFolder: 3,
      vaultname: 4,
      showMenu: 5,
      showLevelSelect: 6,
      showOrder: 7,
      newNote: 8,
      setSearchString: 19,
      openScrollView: 9
    }, add_css2);
  }
};
var TagFolderViewComponent_default = TagFolderViewComponent;

// ScrollView.ts
var import_obsidian3 = __toModule(require("obsidian"));

// ScrollViewMarkdownComponent.svelte
var import_obsidian2 = __toModule(require("obsidian"));
function add_css3(target) {
  append_styles(target, "svelte-1qfikme", ".markdownBody.svelte-1qfikme{user-select:text;-webkit-user-select:text}");
}
function create_fragment3(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "markdownBody svelte-1qfikme");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[3](div);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[3](null);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let { file = { path: "" } } = $$props;
  let { observer } = $$props;
  let el;
  function onAppearing(ev) {
    if (file.content && el) {
      import_obsidian2.MarkdownRenderer.renderMarkdown(file.content, el, file.path, null);
    }
  }
  onMount(() => {
    observer.observe(el);
    el.addEventListener("appearing", onAppearing);
  });
  onDestroy(() => {
    observer.unobserve(el);
    el.removeEventListener("appearing", onAppearing);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el), $$invalidate(1, file);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("file" in $$props2)
      $$invalidate(1, file = $$props2.file);
    if ("observer" in $$props2)
      $$invalidate(2, observer = $$props2.observer);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 3) {
      $: {
        if (file && file.content && el) {
          $$invalidate(0, el.innerHTML = "", el);
          import_obsidian2.MarkdownRenderer.renderMarkdown(file.content, el, file.path, null);
        }
      }
    }
  };
  return [el, file, observer, div_binding];
}
var ScrollViewMarkdownComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, { file: 1, observer: 2 }, add_css3);
  }
};
var ScrollViewMarkdownComponent_default = ScrollViewMarkdownComponent;

// ScrollViewComponent.svelte
function add_css4(target) {
  append_styles(target, "svelte-s1mg0b", ".header.svelte-s1mg0b{background-color:var(--background-secondary-alt);position:sticky;top:0;color:var(--text-normal);margin-bottom:8px}.file.svelte-s1mg0b{cursor:pointer}.path.svelte-s1mg0b{font-size:75%}hr.svelte-s1mg0b{margin:8px auto}");
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i];
  return child_ctx;
}
function create_each_block3(ctx) {
  let div1;
  let div0;
  let span0;
  let t0_value = ctx[11].title + "";
  let t0;
  let t1;
  let span1;
  let t2;
  let t3_value = ctx[11].path + "";
  let t3;
  let t4;
  let t5;
  let scrollviewmarkdown;
  let t6;
  let hr;
  let t7;
  let current;
  let mounted;
  let dispose;
  scrollviewmarkdown = new ScrollViewMarkdownComponent_default({
    props: {
      file: ctx[11],
      observer: ctx[1]
    }
  });
  function click_handler(...args) {
    return ctx[8](ctx[11], ...args);
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      span0 = element("span");
      t0 = text(t0_value);
      t1 = space();
      span1 = element("span");
      t2 = text("(");
      t3 = text(t3_value);
      t4 = text(")");
      t5 = space();
      create_component(scrollviewmarkdown.$$.fragment);
      t6 = space();
      hr = element("hr");
      t7 = space();
      attr(span1, "class", "path svelte-s1mg0b");
      attr(div0, "class", "header svelte-s1mg0b");
      attr(hr, "class", "svelte-s1mg0b");
      attr(div1, "class", "file svelte-s1mg0b");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, span0);
      append(span0, t0);
      append(div0, t1);
      append(div0, span1);
      append(span1, t2);
      append(span1, t3);
      append(span1, t4);
      append(div1, t5);
      mount_component(scrollviewmarkdown, div1, null);
      append(div1, t6);
      append(div1, hr);
      append(div1, t7);
      ctx[9](div1);
      current = true;
      if (!mounted) {
        dispose = listen(div1, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & 8) && t0_value !== (t0_value = ctx[11].title + ""))
        set_data(t0, t0_value);
      if ((!current || dirty & 8) && t3_value !== (t3_value = ctx[11].path + ""))
        set_data(t3, t3_value);
      const scrollviewmarkdown_changes = {};
      if (dirty & 8)
        scrollviewmarkdown_changes.file = ctx[11];
      if (dirty & 2)
        scrollviewmarkdown_changes.observer = ctx[1];
      scrollviewmarkdown.$set(scrollviewmarkdown_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(scrollviewmarkdown.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(scrollviewmarkdown.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(scrollviewmarkdown);
      ctx[9](null);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment4(ctx) {
  let div1;
  let div0;
  let t0;
  let t1;
  let t2;
  let hr;
  let t3;
  let current;
  let each_value = ctx[3];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t0 = text("Files in ");
      t1 = text(ctx[2]);
      t2 = space();
      hr = element("hr");
      t3 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "header svelte-s1mg0b");
      attr(hr, "class", "svelte-s1mg0b");
      attr(div1, "class", "x");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, t0);
      append(div0, t1);
      append(div1, t2);
      append(div1, hr);
      append(div1, t3);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div1, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 4)
        set_data(t1, ctx2[2]);
      if (dirty & 27) {
        each_value = ctx2[3];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div1, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let files;
  let tagPath;
  let { store = writable({ files: [], title: "", tagPath: "" }) } = $$props;
  let { openfile } = $$props;
  let state = { files: [], title: "", tagPath: "" };
  function handleOpenFile(e, file) {
    openfile(file.path);
    e.preventDefault();
  }
  let scrollEl;
  let observer;
  const onAppearing = new CustomEvent("appearing", { detail: {} });
  onMount(() => {
    const options = {
      root: scrollEl,
      rootMargin: "10px",
      threshold: 0
    };
    $$invalidate(1, observer = new IntersectionObserver((entries) => {
      for (const entry of entries) {
        if (entry.isIntersecting) {
          entry.target.dispatchEvent(onAppearing);
        }
      }
    }, options));
  });
  onDestroy(() => {
    observer.disconnect();
  });
  const click_handler = (file, evt) => handleOpenFile(evt, file);
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      scrollEl = $$value;
      $$invalidate(0, scrollEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("store" in $$props2)
      $$invalidate(5, store = $$props2.store);
    if ("openfile" in $$props2)
      $$invalidate(6, openfile = $$props2.openfile);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 32) {
      $: {
        store.subscribe((_state) => {
          $$invalidate(7, state = { ..._state });
          return () => {
          };
        });
      }
    }
    if ($$self.$$.dirty & 128) {
      $:
        $$invalidate(3, files = state.files);
    }
    if ($$self.$$.dirty & 128) {
      $:
        $$invalidate(2, tagPath = state.tagPath.split("/").map((e) => renderSpecialTag(e)).join("/"));
    }
  };
  return [
    scrollEl,
    observer,
    tagPath,
    files,
    handleOpenFile,
    store,
    openfile,
    state,
    click_handler,
    div1_binding
  ];
}
var ScrollViewComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, { store: 5, openfile: 6 }, add_css4);
  }
};
var ScrollViewComponent_default = ScrollViewComponent;

// ScrollView.ts
var ScrollView = class extends import_obsidian3.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.state = { files: [], title: "", tagPath: "" };
    this.plugin = plugin;
    this.store = writable({ files: [], title: "", tagPath: "" });
  }
  getIcon() {
    return "sheets-in-box";
  }
  getViewType() {
    return VIEW_TYPE_SCROLL;
  }
  getDisplayText() {
    return this.state.tagPath || "Tags scroll";
  }
  async setFile(filenames) {
    this.state = { ...this.state, files: filenames };
    await this.updateView();
  }
  async setState(state, result) {
    this.state = { ...state };
    this.title = state.title;
    await this.updateView();
    result = {};
    return;
  }
  getState() {
    return this.state;
  }
  isFileOpened(path) {
    return this.state.files.some((e) => e.path == path);
  }
  getScrollViewState() {
    return this.state;
  }
  async updateView() {
    const items = [];
    for (const item of this.state.files) {
      if (item.content) {
        items.push(item);
      } else {
        const f = this.app.vault.getAbstractFileByPath(item.path);
        if (f == null || !(f instanceof import_obsidian3.TFile)) {
          console.log(`File not found:${item.path}`);
          items.push(item);
          continue;
        }
        const title = this.plugin.getFileTitle(f);
        const w = await this.app.vault.read(f);
        await doEvents();
        item.content = w;
        item.title = title;
        items.push(item);
      }
    }
    this.state = { ...this.state, files: [...items] };
    this.store.set(this.state);
  }
  async onOpen() {
    this.component = new ScrollViewComponent_default({
      target: this.contentEl,
      props: {
        store: this.store,
        openfile: this.plugin.focusFile
      }
    });
  }
  async onClose() {
    this.component.$destroy();
  }
};

// main.ts
var HideItemsType = {
  NONE: "Hide nothing",
  DEDICATED_INTERMIDIATES: "Only intermediates of nested tags",
  ALL_EXCEPT_BOTTOM: "All intermediates"
};
var VIEW_TYPE_TAGFOLDER = "tagfolder-view";
var OrderKeyTag = {
  NAME: "File name",
  ITEMS: "Count of items"
};
var OrderDirection = {
  ASC: "Ascending",
  DESC: "Descending"
};
var OrderKeyItem = {
  DISPNAME: "Displaying name",
  NAME: "File name",
  MTIME: "Modified time",
  CTIME: "Created time",
  FULLPATH: "Fullpath of the file"
};
var dotted = (object, notation) => {
  return notation.split(".").reduce((a, b) => a && b in a ? a[b] : null, object);
};
var compare = Intl && Intl.Collator ? new Intl.Collator().compare : (x, y) => `${x != null ? x : ""}`.localeCompare(`${y != null ? y : ""}`);
var TagFolderView = class extends import_obsidian4.ItemView {
  getIcon() {
    return "stacked-levels";
  }
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.showMenu = this.showMenu.bind(this);
    this.showOrder = this.showOrder.bind(this);
    this.newNote = this.newNote.bind(this);
    this.showLevelSelect = this.showLevelSelect.bind(this);
  }
  newNote(evt) {
    this.app.commands.executeCommandById("file-explorer:new-file");
  }
  showOrder(evt) {
    const menu = new import_obsidian4.Menu();
    menu.addItem((item) => {
      item.setTitle("Tags").setIcon("hashtag").onClick(async (evt2) => {
        const menu2 = new import_obsidian4.Menu();
        for (const key in OrderKeyTag) {
          for (const direction in OrderDirection) {
            menu2.addItem((item2) => {
              const newSetting = `${key}_${direction}`;
              item2.setTitle(OrderKeyTag[key] + " " + OrderDirection[direction]).onClick(async () => {
                this.plugin.settings.sortTypeTag = newSetting;
                await this.plugin.saveSettings();
                this.plugin.setRoot(this.plugin.root);
              });
              if (newSetting == this.plugin.settings.sortTypeTag) {
                item2.setIcon("checkmark");
              }
              menu2.showAtMouseEvent(evt);
              return item2;
            });
          }
        }
      });
      return item;
    });
    menu.addItem((item) => {
      item.setTitle("Items").setIcon("document").onClick(async (evt2) => {
        const menu2 = new import_obsidian4.Menu();
        for (const key in OrderKeyItem) {
          for (const direction in OrderDirection) {
            menu2.addItem((item2) => {
              const newSetting = `${key}_${direction}`;
              item2.setTitle(OrderKeyItem[key] + " " + OrderDirection[direction]).onClick(async () => {
                this.plugin.settings.sortType = newSetting;
                await this.plugin.saveSettings();
                this.plugin.setRoot(this.plugin.root);
              });
              if (newSetting == this.plugin.settings.sortType) {
                item2.setIcon("checkmark");
              }
              menu2.showAtMouseEvent(evt);
              return item2;
            });
          }
        }
      });
      return item;
    });
    menu.showAtMouseEvent(evt);
  }
  showLevelSelect(evt) {
    const menu = new import_obsidian4.Menu();
    const setLevel = async (level) => {
      this.plugin.settings.expandLimit = level;
      await this.plugin.saveSettings();
      maxDepth.set(level);
      this.plugin.setRoot(this.plugin.root);
    };
    for (const level of [2, 3, 4, 5]) {
      menu.addItem((item) => {
        item.setTitle(`Level ${level - 1}`).onClick(() => {
          setLevel(level);
        });
        if (this.plugin.settings.expandLimit == level)
          item.setIcon("checkmark");
        return item;
      });
    }
    menu.addItem((item) => {
      item.setTitle("No limit").onClick(() => {
        setLevel(0);
      });
      if (this.plugin.settings.expandLimit == 0)
        item.setIcon("checkmark");
      return item;
    });
    menu.showAtMouseEvent(evt);
  }
  getViewType() {
    return VIEW_TYPE_TAGFOLDER;
  }
  getDisplayText() {
    return "Tag Folder";
  }
  async onOpen() {
    this.component = new TagFolderViewComponent_default({
      target: this.contentEl,
      props: {
        openfile: this.plugin.focusFile,
        hoverPreview: this.plugin.hoverPreview,
        expandFolder: this.plugin.expandFolder,
        vaultname: this.app.vault.getName(),
        showMenu: this.showMenu,
        showLevelSelect: this.showLevelSelect,
        showOrder: this.showOrder,
        newNote: this.newNote,
        setSearchString: this.plugin.setSearchString,
        openScrollView: this.plugin.openScrollView
      }
    });
  }
  async onClose() {
    this.component.$destroy();
  }
  setTreeRoot(root) {
    treeRoot.set(root);
  }
  showMenu(evt, path, entry) {
    const entryPath = "tag" in entry ? [...ancestorToTags(entry.ancestors)] : ["root", ...entry.tags];
    if ("tag" in entry) {
      const oTags = omittedTags(entry);
      if (oTags != false) {
        entryPath.push(...oTags);
      }
    }
    entryPath.shift();
    const expandedTagsAll = ancestorToLongestTag(ancestorToTags(entryPath));
    const expandedTags = expandedTagsAll.map((e) => e.split("/").filter((ee) => !isSpecialTag(ee)).join("/")).filter((e) => e != "").map((e) => "#" + e).join(" ").trim();
    const displayExpandedTags = expandedTagsAll.map((e) => e.split("/").filter((ee) => renderSpecialTag(ee)).join("/")).filter((e) => e != "").map((e) => "#" + e).join(" ").trim();
    const menu = new import_obsidian4.Menu();
    if (navigator && navigator.clipboard) {
      menu.addItem((item) => item.setTitle(`Copy tags:${expandedTags}`).setIcon("hashtag").onClick(async () => {
        await navigator.clipboard.writeText(expandedTags);
        new import_obsidian4.Notice("Copied");
      }));
    }
    menu.addItem((item) => item.setTitle(`New note ${"tag" in entry ? "in here" : "as like this"}`).setIcon("create-new").onClick(async () => {
      const ww = await this.app.fileManager.createAndOpenMarkdownFile();
      await this.app.vault.append(ww, expandedTags);
    }));
    if ("tag" in entry) {
      if (this.plugin.settings.useTagInfo && this.plugin.tagInfo != null) {
        const tag = entry.ancestors[entry.ancestors.length - 1];
        if (tag in this.plugin.tagInfo && this.plugin.tagInfo[tag]) {
          menu.addItem((item) => item.setTitle(`Unpin`).setIcon("pin").onClick(async () => {
            this.plugin.tagInfo = {
              ...this.plugin.tagInfo,
              [tag]: void 0
            };
            this.plugin.applyTagInfo();
            await this.plugin.saveTagInfo();
          }));
        } else {
          menu.addItem((item) => {
            item.setTitle(`Pin`).setIcon("pin").onClick(async () => {
              this.plugin.tagInfo = {
                ...this.plugin.tagInfo,
                [tag]: { key: "" }
              };
              this.plugin.applyTagInfo();
              await this.plugin.saveTagInfo();
            });
          });
        }
        menu.addItem((item) => {
          item.setTitle(`Open scroll view`).setIcon("sheets-in-box").onClick(async () => {
            const files = entry.allDescendants.map((e) => e.path);
            const tagPath = entry.ancestors.join("/");
            await this.plugin.openScrollView(null, displayExpandedTags, tagPath, files);
          });
        });
      }
    }
    if ("path" in entry) {
      const path2 = entry.path;
      const file = this.app.vault.getAbstractFileByPath(path2);
      this.app.workspace.trigger("file-menu", menu, file, "file-explorer");
    }
    if ("tags" in entry) {
      menu.addSeparator();
      menu.addItem((item) => item.setTitle(`Open in new tab`).setIcon("lucide-file-plus").onClick(async () => {
        app.workspace.openLinkText(entry.path, entry.path, "tab");
      }));
      menu.addItem((item) => item.setTitle(`Open to the right`).setIcon("lucide-separator-vertical").onClick(async () => {
        app.workspace.openLinkText(entry.path, entry.path, "split");
      }));
    }
    if ("screenX" in evt) {
      menu.showAtPosition({ x: evt.pageX, y: evt.pageY });
    } else {
      menu.showAtPosition({
        x: evt.nativeEvent.locationX,
        y: evt.nativeEvent.locationY
      });
    }
  }
};
var rippleDirty = (entry) => {
  for (const child of entry.children) {
    if ("tag" in child) {
      if (rippleDirty(child)) {
        entry.descendants = null;
        entry.allDescendants = null;
        entry.descendantsMemo = null;
      }
    }
  }
  if (entry.descendants == null)
    return true;
};
var retrieveAllDescendants = (entry) => {
  return ("tag" in entry ? entry.children.map((e) => "tag" in e ? [...e.descendants, ...retrieveAllDescendants(e)] : [e]) : [entry]).flat();
};
var retrieveChildren = (entry) => {
  return ("tag" in entry ? entry.children.map((e) => "tag" in e ? [...retrieveChildren(e)] : [e]) : [entry]).flat();
};
var expandDescendants = (entry, hideItems) => {
  const ret = [];
  for (const v of entry.children) {
    if ("tag" in v) {
      if (v.descendants == null) {
        const w = expandDescendants(v, hideItems).filter((e) => !ret.contains(e));
        ret.push(...w);
      } else {
        const w = v.descendants.filter((e) => !ret.contains(e));
        ret.push(...w);
      }
    } else {
      if (!ret.contains(v))
        ret.push(v);
    }
  }
  const leafs = entry.descendantsMemo != null ? entry.descendantsMemo : entry.descendantsMemo = [...new Set(entry.children.map((e) => "tag" in e ? e.children.map((ee) => retrieveAllDescendants(ee).flat()).flat() : []).flat())];
  if (hideItems == "DEDICATED_INTERMIDIATES" && entry.isDedicatedTree || hideItems == "ALL_EXCEPT_BOTTOM") {
    entry.descendants = ret.filter((e) => !leafs.contains(e));
  } else {
    entry.descendants = ret;
  }
  entry.allDescendants = ret;
  entry.itemsCount = new Set([...ret, ...leafs]).size;
  return ret;
};
var expandTree = async (node, reduceNestedParent) => {
  let modified = false;
  const tree = node.children;
  const ancestor = [...node.ancestors];
  const tags = Array.from(new Set(node.children.filter((e) => "tags" in e).map((e) => e.tags).flat()));
  const ancestorAsTags = ancestorToTags(ancestor);
  for (const tag of tags) {
    if (ancestorAsTags.map((e) => e.toLocaleLowerCase()).contains(tag.toLocaleLowerCase()))
      continue;
    const newChildren = node.children.filter((e) => "tags" in e && e.tags.map((e2) => e2.toLocaleLowerCase()).contains(tag.toLocaleLowerCase()));
    if (tree.find((e) => "tag" in e && e.tag.toLocaleLowerCase() == tag.toLocaleLowerCase())) {
      continue;
    }
    const newLeaf = {
      tag,
      children: newChildren,
      ancestors: [...new Set([...ancestor, tag])],
      descendants: null,
      isDedicatedTree: false,
      itemsCount: newChildren.length,
      allDescendants: null
    };
    tree.push(newLeaf);
  }
  modified = await splitTag(node, reduceNestedParent) || modified;
  if (modified) {
    await expandTree(node, reduceNestedParent);
  }
  return modified;
};
var splitTag = async (entry, reduceNestedParent, root) => {
  let modified = false;
  const xRoot = root || entry;
  await doEvents();
  entry.children = entry.children.sort((a, b) => {
    if ("tag" in a && "tag" in b) {
      return a.tag.split("/").length - b.tag.split("/").length;
    } else {
      return 0;
    }
  });
  for (const curEntry of entry.children) {
    if ("tag" in curEntry) {
      modified = await splitTag(curEntry, reduceNestedParent, xRoot) || modified;
      if (curEntry.tag.contains("/")) {
        const tempEntry = curEntry;
        entry.children.remove(tempEntry);
        const tagsArray = tempEntry.tag.split("/");
        const tagCar = tagsArray.shift();
        const tagCdr = SUBTREE_MARK + tagsArray.join("/");
        const ancestors = curEntry.ancestors.map((e) => e.toLocaleLowerCase());
        const newAncestorsBase = tempEntry.ancestors.filter((e) => e != tempEntry.tag);
        const idxCar = ancestors.indexOf(tagCar.toLocaleLowerCase());
        const idxCdr = ancestors.indexOf(tagCdr.toLocaleLowerCase());
        if (idxCar != -1) {
          if (idxCar < idxCdr) {
            modified = true;
            continue;
          } else {
            if (reduceNestedParent) {
              modified = true;
              const replacer = {
                ...tempEntry,
                tag: tagCdr,
                ancestors: [
                  ...newAncestorsBase,
                  tagCar,
                  tagCdr
                ],
                itemsCount: 0,
                descendants: null,
                allDescendants: null,
                isDedicatedTree: tempEntry.isDedicatedTree
              };
              const old = entry.children.find((e) => "tag" in e && e.tag == tagCdr);
              if (old) {
                entry.children.remove(old);
                replacer.children = [...replacer.children, ...old.children];
              }
              entry.children.push(replacer);
              continue;
            }
          }
        }
        const parent = entry.children.find((e) => "tag" in e && e.tag.toLocaleLowerCase() == tagCar.toLocaleLowerCase());
        const tempChildren = tempEntry.children;
        if (!parent) {
          const newGrandchild = {
            tag: tagCdr,
            children: [...tempChildren],
            ancestors: [
              ...newAncestorsBase,
              tagCar,
              tagCdr
            ],
            itemsCount: 0,
            descendants: null,
            allDescendants: null,
            isDedicatedTree: false
          };
          const newChild = {
            tag: tagCar,
            children: [newGrandchild],
            ancestors: [...new Set([...newAncestorsBase, tagCar])],
            descendants: null,
            allDescendants: null,
            isDedicatedTree: true,
            itemsCount: 0
          };
          newChild.children = [newGrandchild];
          entry.children.push(newChild);
          await splitTag(entry, reduceNestedParent, xRoot);
          modified = true;
        } else {
          const oldIx = parent.children.find((e) => "tag" in e && e.tag.toLocaleLowerCase() == tagCdr.toLocaleLowerCase());
          if (oldIx != null) {
            oldIx.children.push(...tempChildren.filter((e) => !oldIx.children.contains(e)));
            await splitTag(oldIx, reduceNestedParent, xRoot);
          } else {
            const x = {
              tag: tagCdr,
              children: [...tempChildren],
              ancestors: [
                ...newAncestorsBase,
                tagCar,
                tagCdr
              ],
              descendants: null,
              allDescendants: null,
              isDedicatedTree: false,
              itemsCount: 0
            };
            parent.children.push(x);
            if (!parent.isDedicatedTree) {
              const p = retrieveChildren(parent).map((e) => e.path);
              const c = retrieveChildren(tempEntry).map((e) => e.path);
              if (c.some((entry2) => !p.contains(entry2))) {
                parent.isDedicatedTree = false;
              } else {
                parent.isDedicatedTree = true;
              }
            }
            await splitTag(parent, reduceNestedParent, xRoot);
          }
          modified = true;
        }
      }
    }
  }
  if (modified) {
    modified = await splitTag(entry, reduceNestedParent, xRoot);
  }
  if (modified) {
    if (entry.isDedicatedTree && entry.children.some((e) => "tags" in e)) {
      entry.isDedicatedTree = false;
    }
  }
  return modified;
};
function getTagName(tagName, tagInfo2, invert) {
  if (tagInfo2 == null)
    return tagName;
  const prefix = invert == -1 ? `\uFFFF` : ``;
  const unpinned = invert == 1 ? `\uFFFF` : ``;
  if (tagName in tagInfo2 && tagInfo2[tagName]) {
    if ("key" in tagInfo2[tagName]) {
      const k = `${prefix}_-${tagInfo2[tagName].key}__${tagName}`;
      return k;
    }
  }
  return `${prefix}_${unpinned}_${tagName}`;
}
function getCompareMethodTags(settings) {
  const invert = settings.sortTypeTag.contains("_DESC") ? -1 : 1;
  switch (settings.sortTypeTag) {
    case "ITEMS_ASC":
    case "ITEMS_DESC":
      return (a, b, tagInfo2) => (a.itemsCount - b.itemsCount) * invert;
    case "NAME_ASC":
    case "NAME_DESC":
      return (a, b, tagInfo2) => compare(getTagName(a.tag, settings.useTagInfo ? tagInfo2 : null, invert), getTagName(b.tag, settings.useTagInfo ? tagInfo2 : null, invert)) * invert;
    default:
      console.warn("Compare method (tags) corrupted");
      return (a, b, tagInfo2) => compare(a.tag, b.tag) * invert;
  }
}
function getCompareMethodItems(settings) {
  const invert = settings.sortType.contains("_DESC") ? -1 : 1;
  switch (settings.sortType) {
    case "DISPNAME_ASC":
    case "DISPNAME_DESC":
      return (a, b) => compare(a.displayName, b.displayName) * invert;
    case "FULLPATH_ASC":
    case "FULLPATH_DESC":
      return (a, b) => compare(a.path, b.path) * invert;
    case "MTIME_ASC":
    case "MTIME_DESC":
      return (a, b) => (a.mtime - b.mtime) * invert;
    case "CTIME_ASC":
    case "CTIME_DESC":
      return (a, b) => (a.ctime - b.ctime) * invert;
    case "NAME_ASC":
    case "NAME_DESC":
      return (a, b) => compare(a.filename, b.filename) * invert;
    default:
      console.warn("Compare method (items) corrupted");
      return (a, b) => compare(a.displayName, b.displayName) * invert;
  }
}
var TagFolderPlugin = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    this.expandedFolders = ["root"];
    this.currentOpeningFile = "";
    this.searchString = "";
    this.focusFile = (path, specialKey) => {
      const targetFile = this.app.vault.getFiles().find((f) => f.path === path);
      if (targetFile) {
        if (specialKey) {
          app.workspace.openLinkText(targetFile.path, targetFile.path, "split");
        } else {
          app.workspace.openLinkText(targetFile.path, targetFile.path);
        }
      }
    };
    this.expandingProcs = 0;
    this.expandFolder = async (entry, expanded) => {
      if ("tag" in entry) {
        const key = [...entry.ancestors].join("/");
        if (expanded) {
          this.expandedFolders = Array.from(new Set([...this.expandedFolders, key]));
          this.expandedFolders = this.expandedFolders.sort((a, b) => a.split("/").length - b.split("/").length);
        } else {
          this.expandedFolders = this.expandedFolders.filter((e) => e != key);
        }
        await this.expandLastExpandedFolders(entry);
        this.setRoot(this.root);
      }
    };
    this.fileCaches = [];
    this.oldFileCache = "";
    this.lastTags = "";
    this.lastSettings = "";
    this.lastSearchString = "";
    this.tagInfo = null;
    this.tagInfoFrontMatterBuffer = {};
    this.tagInfoBody = "";
  }
  getView() {
    for (const leaf of this.app.workspace.getLeavesOfType(VIEW_TYPE_TAGFOLDER)) {
      const view = leaf.view;
      if (view instanceof TagFolderView) {
        return view;
      }
    }
    return null;
  }
  hoverPreview(e, path) {
    this.app.workspace.trigger("hover-link", {
      event: e,
      source: "file-explorer",
      hoverParent: this,
      targetEl: e.target,
      linktext: path
    });
  }
  setSearchString(search) {
    this.searchString = search;
    this.refreshAllTree(null);
  }
  async expandLastExpandedFolders(entry, force, path = [], openedTags = {}, maxDepth2 = 1) {
    if (maxDepth2 < 0) {
      return;
    }
    if ("tag" in entry) {
      if (path.indexOf(entry.tag) !== -1)
        return;
      if (omittedTags(entry))
        return;
      const key = entry.ancestors.join("/");
      for (const tags of this.expandedFolders) {
        const tagPrefixToOpen = [];
        const tagArray = tags.split("/");
        for (const f of tagArray) {
          tagPrefixToOpen.push(f);
          const tagPrefix = tagPrefixToOpen.join("/");
          if (!(tagPrefix in openedTags)) {
            openedTags[tagPrefix] = new Set();
          }
          if (openedTags[tagPrefix].has(key)) {
            continue;
          }
          if (key.startsWith(tagPrefix) || force) {
            openedTags[tagPrefix].add(key);
            await expandTree(entry, this.settings.reduceNestedParent);
            await splitTag(entry, this.settings.reduceNestedParent);
            for (const child of entry.children) {
              if ("tag" in child) {
                const autoExp = isAutoExpandTree(child);
                const nextDepth = autoExp ? maxDepth2 : maxDepth2 - 1;
                if (path.indexOf(child.tag) == -1) {
                  await this.expandLastExpandedFolders(child, false, [...path, entry.tag], openedTags, nextDepth);
                }
              }
            }
          }
        }
      }
    }
  }
  getFileTitle(file) {
    if (!this.settings.useTitle)
      return file.basename;
    const metadata = this.app.metadataCache.getCache(file.path);
    if (metadata.frontmatter && this.settings.frontmatterKey) {
      const d = dotted(metadata.frontmatter, this.settings.frontmatterKey);
      if (d)
        return d;
    }
    if (metadata.headings) {
      const h1 = metadata.headings.find((e) => e.level == 1);
      if (h1) {
        return h1.heading;
      }
    }
    return file.basename;
  }
  getDisplayName(file) {
    const filename = this.getFileTitle(file) || file.basename;
    if (this.settings.displayMethod == "NAME") {
      return filename;
    }
    const path = file.path.split("/");
    path.pop();
    const displayPath = path.join("/");
    if (this.settings.displayMethod == "NAME : PATH") {
      return `${filename} : ${displayPath}`;
    }
    if (this.settings.displayMethod == "PATH/NAME") {
      return `${displayPath}/${filename}`;
    }
    return filename;
  }
  async onload() {
    await this.loadSettings();
    this.hoverPreview = this.hoverPreview.bind(this);
    this.sortChildren = this.sortChildren.bind(this);
    this.modifyFile = this.modifyFile.bind(this);
    this.setSearchString = this.setSearchString.bind(this);
    this.openScrollView = this.openScrollView.bind(this);
    this.loadFileInfo = (0, import_obsidian4.debounce)(this.loadFileInfo.bind(this), this.settings.scanDelay, true);
    this.registerView(VIEW_TYPE_TAGFOLDER, (leaf) => new TagFolderView(leaf, this));
    this.registerView(VIEW_TYPE_SCROLL, (leaf) => new ScrollView(leaf, this));
    this.app.workspace.onLayoutReady(async () => {
      if (this.settings.alwaysOpen) {
        this.activateView();
      }
    });
    this.addCommand({
      id: "tagfolder-open",
      name: "Show Tag Folder",
      callback: () => {
        this.activateView();
      }
    });
    this.metadataCacheChanged = this.metadataCacheChanged.bind(this);
    this.watchWorkspaceOpen = this.watchWorkspaceOpen.bind(this);
    this.registerEvent(this.app.metadataCache.on("changed", this.metadataCacheChanged));
    this.refreshAllTree = this.refreshAllTree.bind(this);
    this.registerEvent(this.app.vault.on("rename", this.refreshAllTree));
    this.registerEvent(this.app.vault.on("delete", this.refreshAllTree));
    this.registerEvent(this.app.vault.on("modify", this.modifyFile));
    this.registerEvent(this.app.workspace.on("file-open", this.watchWorkspaceOpen));
    this.watchWorkspaceOpen(this.app.workspace.getActiveFile());
    this.addSettingTab(new TagFolderSettingTab(this.app, this));
    maxDepth.set(this.settings.expandLimit);
    if (this.settings.useTagInfo) {
      this.app.workspace.onLayoutReady(async () => {
        await this.loadTagInfo();
      });
    }
  }
  watchWorkspaceOpen(file) {
    if (file) {
      this.currentOpeningFile = file.path;
    } else {
      this.currentOpeningFile = "";
    }
    currentFile.set(this.currentOpeningFile);
  }
  metadataCacheChanged(file) {
    this.loadFileInfo(file);
  }
  refreshAllTree(file) {
    this.loadFileInfo();
  }
  sortChildren(a, b) {
    if ("tag" in a && !("tag" in b)) {
      return -1;
    } else if (!("tag" in a) && "tag" in b) {
      return 1;
    } else {
      if ("tag" in a && "tag" in b) {
        return this.compareTags(a, b, this.tagInfo);
      } else if ("tags" in a && "tags" in b) {
        return this.compareItems(a, b);
      } else {
        return 0;
      }
    }
  }
  sortTree(entry) {
    entry.children = entry.children.sort(this.sortChildren);
    for (const child of entry.children) {
      if ("tag" in child) {
        this.sortTree(child);
      }
    }
    entry.descendants = entry.descendants.sort(this.sortChildren);
  }
  snipEmpty(root) {
    for (const v of root.children) {
      if ("tag" in v)
        this.snipEmpty(v);
    }
    root.children = root.children.filter((e) => !("tag" in e && e.children.length == 0));
  }
  mergeRedundantCombination(root) {
    const existentChild = {};
    const removeChildren = [];
    for (const entry of root.children) {
      if (!("tag" in entry))
        continue;
      if ("tag" in entry)
        this.mergeRedundantCombination(entry);
    }
    for (const entry of root.children) {
      if (!("tag" in entry))
        continue;
      const tags = [...new Set(retrieveAllDescendants(entry))].map((e) => e.path).sort().join("-");
      if (tags in existentChild) {
        removeChildren.push(entry);
      } else {
        existentChild[tags] = entry;
      }
    }
    for (const v of removeChildren) {
      root.children.remove(v);
    }
    root.children = [...root.children];
  }
  setRoot(root) {
    var _a;
    rippleDirty(root);
    expandDescendants(root, this.settings.hideItems);
    this.snipEmpty(root);
    this.sortTree(root);
    if (this.settings.mergeRedundantCombination)
      this.mergeRedundantCombination(root);
    this.root = root;
    (_a = this.getView()) == null ? void 0 : _a.setTreeRoot(root);
  }
  updateFileCaches(diff) {
    if (this.fileCaches.length == 0 || !diff) {
      const files = this.app.vault.getMarkdownFiles();
      this.fileCaches = files.map((fileEntry) => {
        return {
          file: fileEntry,
          metadata: this.app.metadataCache.getFileCache(fileEntry)
        };
      });
    } else {
      this.fileCaches = this.fileCaches.filter((fileCache) => fileCache.file.path != diff.path);
      this.fileCaches.push({
        file: diff,
        metadata: this.app.metadataCache.getFileCache(diff)
      });
    }
    const fileCacheDump = JSON.stringify(this.fileCaches.map((e) => {
      var _a, _b;
      return {
        path: e.file.path,
        tags: ((_b = (_a = e.metadata) == null ? void 0 : _a.tags) != null ? _b : []).map((e2) => e2.tag)
      };
    }));
    if (this.oldFileCache == fileCacheDump) {
      return false;
    } else {
      this.oldFileCache = fileCacheDump;
      return true;
    }
  }
  async getItemsList() {
    var _a;
    const items = [];
    const ignoreDocTags = this.settings.ignoreDocTags.toLocaleLowerCase().replace(/\n| /g, "").split(",");
    const ignoreTags = this.settings.ignoreTags.toLocaleLowerCase().replace(/\n| /g, "").split(",");
    const ignoreFolders = this.settings.ignoreFolders.toLocaleLowerCase().replace(/\n/g, "").split(",").map((e) => e.trim()).filter((e) => !!e);
    const targetFolders = this.settings.targetFolders.toLocaleLowerCase().replace(/\n/g, "").split(",").map((e) => e.trim()).filter((e) => !!e);
    const searchItems = this.searchString.toLocaleLowerCase().split("|").map((ee) => ee.split(" ").map((e) => e.trim()));
    const today = Date.now();
    for (const fileCache of this.fileCaches) {
      if (targetFolders.length > 0 && !targetFolders.some((e) => {
        return e != "" && fileCache.file.path.toLocaleLowerCase().startsWith(e);
      })) {
        continue;
      }
      if (ignoreFolders.some((e) => e != "" && fileCache.file.path.toLocaleLowerCase().startsWith(e))) {
        continue;
      }
      await doEvents();
      const allTagsDocs = [...new Set((_a = (0, import_obsidian4.getAllTags)(fileCache.metadata)) != null ? _a : [])];
      let allTags2 = allTagsDocs.map((e) => e.substring(1));
      if (this.settings.disableNestedTags) {
        allTags2 = allTags2.map((e) => e.split("/")).flat();
      }
      if (allTags2.length == 0) {
        allTags2 = ["_untagged"];
      }
      if (this.settings.useVirtualTag) {
        const mtime = fileCache.file.stat.mtime;
        const diff = today - mtime;
        const disp = secondsToFreshness(diff);
        allTags2.push(`_VIRTUAL_TAG_FRESHNESS/${disp}`);
      }
      if (allTags2.some((tag) => ignoreDocTags.contains(tag.toLocaleLowerCase()))) {
        continue;
      }
      const w = searchItems.map((searchItem) => {
        let bx = false;
        for (const search of searchItem) {
          if (search.startsWith("-")) {
            bx = bx || allTags2.some((tag) => tag.toLocaleLowerCase().contains(search.substring(1)));
            if (bx)
              continue;
          } else {
            bx = bx || allTags2.every((tag) => !tag.toLocaleLowerCase().contains(search));
            if (bx)
              continue;
          }
        }
        return bx;
      });
      if (w.every((e) => e))
        continue;
      allTags2 = allTags2.filter((tag) => !ignoreTags.contains(tag.toLocaleLowerCase()));
      items.push({
        tags: allTags2,
        path: fileCache.file.path,
        displayName: this.getDisplayName(fileCache.file),
        ancestors: [],
        mtime: fileCache.file.stat.mtime,
        ctime: fileCache.file.stat.ctime,
        filename: fileCache.file.basename
      });
    }
    return items;
  }
  async buildUpTree(items) {
    const root = {
      tag: "root",
      children: [...items],
      ancestors: ["root"],
      descendants: null,
      allDescendants: null,
      itemsCount: 0,
      isDedicatedTree: false
    };
    await expandTree(root, this.settings.reduceNestedParent);
    root.children = root.children.filter((e) => "tag" in e);
    await splitTag(root, this.settings.reduceNestedParent);
    await this.expandLastExpandedFolders(root, true);
    return root;
  }
  loadFileInfo(diff) {
    this.loadFileInfoAsync(diff);
  }
  async loadFileInfoAsync(diff) {
    if (this.getView() == null)
      return;
    const strSetting = JSON.stringify(this.settings);
    const isSettingChanged = strSetting != this.lastSettings;
    const isSearchStringModified = this.searchString != this.lastSearchString;
    if (isSettingChanged) {
      this.lastSettings = strSetting;
    }
    if (isSearchStringModified) {
      this.lastSearchString = this.searchString;
    }
    if (!this.updateFileCaches(diff) && !isSearchStringModified && !isSettingChanged) {
      await this.applyUpdateIntoScroll(diff);
      return;
    }
    const items = await this.getItemsList();
    const root = await this.buildUpTree(items);
    this.setRoot(root);
    await this.applyUpdateIntoScroll(diff);
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_TAGFOLDER);
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_SCROLL);
  }
  async openScrollView(leaf, title, tagPath, files) {
    if (!leaf) {
      leaf = this.app.workspace.getLeaf("split");
    }
    await leaf.setViewState({
      type: VIEW_TYPE_SCROLL,
      active: true,
      state: { files: files.map((e) => ({ path: e })), title, tagPath }
    });
    this.app.workspace.revealLeaf(leaf);
  }
  findTreeItemFromPath(tagPath, root) {
    if (!root) {
      root = this.root;
    }
    if (root.children.some((e) => !("tag" in e))) {
      return root;
    }
    const paths = tagPath.split("/");
    paths.shift();
    const path = [];
    while (paths.length > 0) {
      path.push(paths.shift());
      const child = root.children.find((e) => "tag" in e && e.tag == path.join("/"));
      if (child) {
        return this.findTreeItemFromPath(paths.join("/"), child);
      }
    }
    return null;
  }
  async applyUpdateIntoScroll(file) {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_SCROLL);
    for (const leaf of leaves) {
      const view = leaf.view;
      const viewStat = { ...leaf.getViewState(), state: { ...view.getScrollViewState() } };
      if (file && view.isFileOpened(file.path)) {
        const newStat = {
          ...viewStat,
          state: {
            ...viewStat.state,
            files: viewStat.state.files.map((e) => e.path == file.path ? {
              path: file.path
            } : e)
          }
        };
        leaf.setViewState(newStat);
      }
      const openedNode = this.findTreeItemFromPath(viewStat.state.tagPath);
      if (openedNode) {
        const newFilesArray = openedNode.allDescendants.map((e) => e.path);
        const newFiles = newFilesArray.sort().join("-");
        const oldFiles = viewStat.state.files.map((e) => e.path).sort().join("-");
        if (newFiles != oldFiles) {
          const newStat = {
            ...viewStat,
            state: {
              ...viewStat.state,
              files: newFilesArray.map((path) => {
                const old = viewStat.state.files.find((e) => e.path == path);
                if (old)
                  return old;
                return {
                  path
                };
              })
            }
          };
          leaf.setViewState(newStat);
        }
      }
    }
  }
  async activateView() {
    this.loadFileInfo();
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_TAGFOLDER);
    await this.app.workspace.getLeftLeaf(false).setViewState({
      type: VIEW_TYPE_TAGFOLDER,
      active: true
    });
    this.app.workspace.revealLeaf(this.app.workspace.getLeavesOfType(VIEW_TYPE_TAGFOLDER)[0]);
  }
  async modifyFile(file) {
    if (!this.settings.useTagInfo)
      return;
    if (this.skipOnce) {
      this.skipOnce = false;
      return;
    }
    if (file.name == this.getTagInfoFilename()) {
      await this.loadTagInfo();
    }
  }
  getTagInfoFilename() {
    return (0, import_obsidian4.normalizePath)(this.settings.tagInfo);
  }
  getTagInfoFile() {
    const file = this.app.vault.getAbstractFileByPath(this.getTagInfoFilename());
    if (file instanceof import_obsidian4.TFile) {
      return file;
    }
    return null;
  }
  applyTagInfo() {
    if (this.tagInfo == null)
      return;
    if (!this.settings.useTagInfo)
      return;
    tagInfo.set(this.tagInfo);
    setTimeout(() => {
      if (this.root)
        this.setRoot(this.root);
    }, 10);
  }
  async loadTagInfo() {
    var _a;
    if (!this.settings.useTagInfo)
      return;
    if (this.tagInfo == null)
      this.tagInfo = {};
    const file = this.getTagInfoFile();
    if (file == null)
      return;
    const data = await this.app.vault.read(file);
    try {
      const bodyStartIndex = data.indexOf("\n---");
      if (!data.startsWith("---") || bodyStartIndex === -1) {
        return;
      }
      const yaml = data.substring(3, bodyStartIndex);
      const yamlData = (0, import_obsidian4.parseYaml)(yaml);
      const keys = Object.keys(yamlData);
      const body = data.substring(bodyStartIndex + 5);
      this.tagInfoBody = body;
      this.tagInfoFrontMatterBuffer = yamlData;
      const newTagInfo = {};
      for (const key of keys) {
        const w = yamlData[key];
        if (!w)
          continue;
        if (typeof w != "object")
          continue;
        if (!("key" in w))
          continue;
        const eachTag = {
          key: w.key,
          mark: (_a = w.mark) != null ? _a : void 0
        };
        newTagInfo[key] = eachTag;
      }
      this.tagInfo = newTagInfo;
      this.applyTagInfo();
    } catch (ex) {
      console.log(ex);
    }
  }
  async saveTagInfo() {
    if (!this.settings.useTagInfo)
      return;
    if (this.tagInfo == null)
      return;
    const file = this.getTagInfoFile();
    const yaml = (0, import_obsidian4.stringifyYaml)({ ...this.tagInfoFrontMatterBuffer, ...this.tagInfo });
    const w = `---
${yaml}---
${this.tagInfoBody}`;
    this.skipOnce = true;
    if (file == null) {
      this.app.vault.create(this.getTagInfoFilename(), w);
    } else {
      this.app.vault.modify(file, w);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    await this.loadTagInfo();
    this.compareItems = getCompareMethodItems(this.settings);
    this.compareTags = getCompareMethodTags(this.settings);
  }
  async saveSettings() {
    await this.saveData(this.settings);
    await this.saveTagInfo();
    this.compareItems = getCompareMethodItems(this.settings);
    this.compareTags = getCompareMethodTags(this.settings);
  }
};
var TagFolderSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  hide() {
    this.plugin.loadFileInfo();
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for Tag Folder." });
    new import_obsidian4.Setting(containerEl).setName("Always Open").setDesc("Open Tag Folder when obsidian has been launched").addToggle((toggle) => toggle.setValue(this.plugin.settings.alwaysOpen).onChange(async (value) => {
      this.plugin.settings.alwaysOpen = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Display method").setDesc("Filename display").addDropdown((dropdown) => dropdown.addOptions({
      "PATH/NAME": "PATH/NAME",
      NAME: "NAME",
      "NAME : PATH": "NAME : PATH"
    }).setValue(this.plugin.settings.displayMethod).onChange(async (value) => {
      this.plugin.settings.displayMethod = value;
      this.plugin.loadFileInfo(null);
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Use title").setDesc("Use value in the frontmatter or first level one heading for `NAME`.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.useTitle).onChange(async (value) => {
        this.plugin.settings.useTitle = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian4.Setting(containerEl).setName("Frontmatter path").addText((text2) => {
      text2.setValue(this.plugin.settings.frontmatterKey).onChange(async (value) => {
        this.plugin.settings.frontmatterKey = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian4.Setting(containerEl).setName("Use pinning").setDesc("When this feature is enabled, the pin information is saved in the file set in the next configuration.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.useTagInfo).onChange(async (value) => {
        this.plugin.settings.useTagInfo = value;
        if (this.plugin.settings.useTagInfo) {
          await this.plugin.loadTagInfo();
        }
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian4.Setting(containerEl).setName("Pin information file").addText((text2) => {
      text2.setValue(this.plugin.settings.tagInfo).onChange(async (value) => {
        this.plugin.settings.tagInfo = value;
        if (this.plugin.settings.useTagInfo) {
          await this.plugin.loadTagInfo();
        }
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian4.Setting(containerEl).setName("Merge redundant combinations").setDesc("When this feature is enabled, a/b and b/a are merged into a/b if there is no intermediates.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.mergeRedundantCombination).onChange(async (value) => {
        this.plugin.settings.mergeRedundantCombination = value;
        await this.plugin.saveSettings();
      });
    });
    const setOrderMethod = async (key, order) => {
      const oldSetting = this.plugin.settings.sortType.split("_");
      if (!key)
        key = oldSetting[0];
      if (!order)
        order = oldSetting[1];
      this.plugin.settings.sortType = `${key}_${order}`;
      await this.plugin.saveSettings();
      this.plugin.setRoot(this.plugin.root);
    };
    const setOrderMethodTag = async (key, order) => {
      const oldSetting = this.plugin.settings.sortTypeTag.split("_");
      if (!key)
        key = oldSetting[0];
      if (!order)
        order = oldSetting[1];
      this.plugin.settings.sortTypeTag = `${key}_${order}`;
      await this.plugin.saveSettings();
      this.plugin.setRoot(this.plugin.root);
    };
    new import_obsidian4.Setting(containerEl).setName("Order method (Tags)").setDesc("how to order tags").addDropdown((dd) => {
      dd.addOptions(OrderKeyTag).setValue(this.plugin.settings.sortTypeTag.split("_")[0]).onChange((key) => setOrderMethodTag(key, null));
    }).addDropdown((dd) => {
      dd.addOptions(OrderDirection).setValue(this.plugin.settings.sortTypeTag.split("_")[1]).onChange((order) => setOrderMethodTag(null, order));
    });
    new import_obsidian4.Setting(containerEl).setName("Order method (Items)").setDesc("how to order items").addDropdown((dd) => {
      dd.addOptions(OrderKeyItem).setValue(this.plugin.settings.sortType.split("_")[0]).onChange((key) => setOrderMethod(key, null));
    }).addDropdown((dd) => {
      dd.addOptions(OrderDirection).setValue(this.plugin.settings.sortType.split("_")[1]).onChange((order) => setOrderMethod(null, order));
    });
    new import_obsidian4.Setting(containerEl).setName("Do not treat nested tags as dedicated levels").setDesc("Treat nested tags as normal tags").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.disableNestedTags).onChange(async (value) => {
        this.plugin.settings.disableNestedTags = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian4.Setting(containerEl).setName("Reduce duplicated parents in nested tags").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.reduceNestedParent).onChange(async (value) => {
        this.plugin.settings.reduceNestedParent = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian4.Setting(containerEl).setName("Use virtual tags").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.useVirtualTag).onChange(async (value) => {
        this.plugin.settings.useVirtualTag = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian4.Setting(containerEl).setName("Hide Items").setDesc("Hide items on the landing or nested tags").addDropdown((dd) => {
      dd.addOptions(HideItemsType).setValue(this.plugin.settings.hideItems).onChange(async (key) => {
        if (key == "NONE" || key == "DEDICATED_INTERMIDIATES" || key == "ALL_EXCEPT_BOTTOM") {
          this.plugin.settings.hideItems = key;
        }
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian4.Setting(containerEl).setName("Ignore note Tag").setDesc("If the note has the tag listed below, the note would be treated as there was not.").addTextArea((text2) => text2.setValue(this.plugin.settings.ignoreDocTags).setPlaceholder("test,test1,test2").onChange(async (value) => {
      this.plugin.settings.ignoreDocTags = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Ignore Tag").setDesc("Tags in the list would be treated as there were not.").addTextArea((text2) => text2.setValue(this.plugin.settings.ignoreTags).setPlaceholder("test,test1,test2").onChange(async (value) => {
      this.plugin.settings.ignoreTags = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Target Folders").setDesc("The plugin will only target files in it.").addTextArea((text2) => text2.setValue(this.plugin.settings.targetFolders).setPlaceholder("study,documents/summary").onChange(async (value) => {
      this.plugin.settings.targetFolders = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Ignore Folders").setDesc("Ignore documents in specific folders.").addTextArea((text2) => text2.setValue(this.plugin.settings.ignoreFolders).setPlaceholder("template,list/standard_tags").onChange(async (value) => {
      this.plugin.settings.ignoreFolders = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Tag scanning delay").setDesc("Sets the delay for reflecting metadata changes to the tag tree. (Plugin reload is required.)").addText((text2) => {
      text2 = text2.setValue(this.plugin.settings.scanDelay + "").onChange(async (value) => {
        const newDelay = Number.parseInt(value, 10);
        if (newDelay) {
          this.plugin.settings.scanDelay = newDelay;
          await this.plugin.saveSettings();
        }
      });
      text2.inputEl.setAttribute("type", "number");
      text2.inputEl.setAttribute("min", "250");
      return text2;
    });
    containerEl.createEl("h3", { text: "Utilities" });
    new import_obsidian4.Setting(containerEl).setName("Dumping tags for reporting bugs").setDesc("If you want to open an issue to the GitHub, this information can be useful. and, also if you want to keep secret about name of tags, you can use `disguised`.").addButton((button) => button.setButtonText("Copy tags").setDisabled(false).onClick(async () => {
      const items = this.plugin.root.allDescendants.map((e) => e.tags.filter((e2) => e2 != "_untagged")).filter((e) => e.length);
      await navigator.clipboard.writeText(items.map((e) => e.map((e2) => `#${e2}`).join(", ")).join("\n"));
      new import_obsidian4.Notice("Copied to clipboard");
    })).addButton((button) => button.setButtonText("Copy disguised tags").setDisabled(false).onClick(async () => {
      const x = new Map();
      let i = 0;
      const items = this.plugin.root.allDescendants.map((e) => e.tags.filter((e2) => e2 != "_untagged").map((e2) => x.has(e2) ? x.get(e2) : (x.set(e2, i++), i))).filter((e) => e.length);
      await navigator.clipboard.writeText(items.map((e) => e.map((e2) => `#tag${e2}`).join(", ")).join("\n"));
      new import_obsidian4.Notice("Copied to clipboard");
    }));
  }
};
